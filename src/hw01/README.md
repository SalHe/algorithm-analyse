# 第一次作业

## 注意事项

1. 请每位同学完成如下作业，下周将随机抽查；
2. 请以小组为单位，共同商讨以下4题的高效算法，撰写一份纸质作业报告，介绍算法的思路、用C或C++语言对算法进行描述、并进行算法分析，截图贴出算法执行结果等，于9月28日提交。

## 题目

### 1. 求和组合

给定含n（n>10）个不同正整数元素的序列A和一个正整数sum。定义A的子集S，S的所有元素之和恰好为sum，设计一个尽可能高效的算法找出元素个数最多的这样的S。例如，int A[]={1,2,3,4}，int sum=6，输出结果为3，满足条件的集合S是由3个元素1、2、3所组成的集合。([查看本题代码](./01.sum.cpp))
 
  > 输入： n,  A
  > 
  > 输出：集合S的基数以及S集合中的每一个元素。

### 2. 调整数列回文

随机输入n个正整数，试设计一高效算法判断该整数数列的逆序序列是否与其一致，若不是，可以循环选择任意相邻的两个整数之和去代替这两个整数（从数列中删除相邻的两个整数，并在该位置插入他们的和），直到数列满足逆序序列与原序列一致为止。输出选择操作的次数以及最后数列的状态。([查看本题代码](./02.palindrome.cpp))

  > 如：输入n=5; 数列为：1 2 3 4 6
  > 
  > 输出：选择次数为2， 最后数列状态位：6 4 6

### 3. 股票投资

假设现在你有一次投资贵州茅台的机会，可以在某个时刻买进1000股该股票，并在之后的某天将其卖出，买进卖出均在交易日结束后进行。现已经预测出该股票将来的价格（连续30个交易日），请设计尽可能高效的算法，计算出获得最大收益的买进卖出时间以及所获得收益的值。([查看核心算法代码](./stocks.h)/[查看测试用例代码](./03.maotai.cpp))

  |      |      |      |      |      |      |      |      |      |      |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
  | 1755 | 1749 | 1724 | 1699 | 1671 | 1693 | 1799 | 1750 | 1690 | 1700 |
  | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   | 20   |
  | 1699 | 1635 | 1620 | 1619 | 1548 | 1570 | 1625 | 1665 | 1595 | 1596 |
  | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   |
  | 1586 | 1558 | 1622 | 1618 | 1658 | 1670 | 1669 | 1633 | 1634 | 1662 |


#### 算法分析

- 参考：
  - [联机算法](https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E7%AE%97%E6%B3%95)
- 算法复杂度：$O(n)$
- 空间复杂度：$O(1)$

##### **[算法](./stocks.h)的大致思路(建议结合源代码查看)：**

  1. 对输入的数列进行遍历，总是记录下一个参考点`tryStart`作为购买日期(初始时参考点为0)，然后每次循环都会计算参考点与当前日期的收益。
      ```c++
      double curr = prices[i] - prices[tryStart];
      ```
  2. 并且在这个循环过程中，总是记录下最大收益时对应的收益值`max`、购入时间`left`、售出时间`right`。我们将当前情况的收益与已记录的最大收益比较，如果当前情况更好，则更新记录。
      ```c++
      if (curr > max)
      {
          max = curr;
          left = tryStart;
          right = i;
      }
      ```
  3. 如果发现收益为负值，说明当前日期的股价更低。那么相对于原参考点，对于**以后遇到的**同一日期，必定有着更高的收入，所以在这种情况下我们变更参考点。（在本次代码实现中，收益为0时也会变更参考点）
      ```c++
      else if (curr <= 0)
      {
          tryStart = i;
      }
      ```

      > 参考点的如此变更使得我们总能选取更低的参考点——因为我们一旦遇到股价低的日期，就会变更参考点。

  4. 最后我们返回记录下来的最佳解即可。
      ```c++
      return {max, left, right};
      ```

##### **思路可行性的证明**

仔细考虑一下我们的算法，实际过程就是：我们在一次遍历中，从遍历到的每一天计算出的收益值中选出最大的一个解作为我们的最优解。

考虑一下，如果我们每次计算出的收益值都是以那一天作为售出日的最高收益的解法，那么最终得出的解必然是所有情况中的最优解。（*某一天的最优解 -> 所有情况的最优解*）

> What's "以那一天作为售出日的最高收益的解法"？
> 
> 比如说对于第$i$天，我们计算的`double curr = prices[i] - prices[tryStart];`是以第$i$天作为售出日，所有可能的股票买法中，收益最大的一种情况——在第$tryStart$天买入。

现在我们尝试证明：*我们每次计算出的收益值都是以那一天作为售出日的最高收益的解法*。

要证明这一点也比较容易，$利润 = 售出日股价 - 购入日股价$。对于某一天来说，那一天(记为第`currDay`天)的股价即$售出日股价$总是同样的，所以关键是$购入日股价$。

显然，要使得`利润`最大，`购入日股价`应最小。

在循环至第`currDay`天之前，我们总是在股价低于参考点股价时将参考点更新为对应的那一天，所以`tryStart`中总是保留着最低股价的那天，也就保证了`购入日股价`，那么也就证明了`利润`最大。

进而说明了*我们每次计算出的收益值都是以那一天作为售出日的最高收益的解法*，也就证明的算法的正确性。

### 4. 真实股票数据测试

请收集某一真实股票2021年连续3个月交易日的股价信息，试用题3所设计的算法计算出2021年最佳买进卖出日期。([查看核心算法代码](./stocks.h)/[查看测试代码](./04.real_stocks.cpp))

  > 在本程序中涉及到股票信息的[爬虫](./04.spider.js)，该爬虫的执行需要Node.js环境。
  > 
  > 爬虫会自动整理爬取结果，并计算出参考答案以C++的风格输出相关的定义供算法实现的C++代码直接使用（省去解析的过程）。
  > Linux系统中可以执行[`04.fetch_stocks.sh`](./04.fetch_stocks.sh)脚本，Windows系统中执行[`04.fetch_stocks.bat`](./04.fetch_stocks.bat)，将自动生成对应的[头文件](./04.real_stocks.h)。
